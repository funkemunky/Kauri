package dev.brighten.anticheat.check.impl.packet.exploits;

import cc.funkemunky.api.Atlas;
import cc.funkemunky.api.bungee.BungeeAPI;
import cc.funkemunky.api.tinyprotocol.api.Packet;
import cc.funkemunky.api.tinyprotocol.listener.PacketInfo;
import cc.funkemunky.api.tinyprotocol.packet.out.WrappedOutCustomPayload;
import cc.funkemunky.api.tinyprotocol.packet.out.WrappedOutPositionPacket;
import cc.funkemunky.api.utils.RunUtils;
import dev.brighten.anticheat.check.api.Check;
import dev.brighten.anticheat.check.api.CheckInfo;
import dev.brighten.anticheat.check.api.Event;
import dev.brighten.anticheat.check.api.Setting;
import dev.brighten.anticheat.processing.PacketProcessor;
import dev.brighten.api.check.CheckType;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import org.bukkit.entity.Player;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@CheckInfo(name = "PacketSpam", description = "Prevents the spam of packets.",
        checkType = CheckType.EXPLOIT, punishVL = 30, executable = false)
public class PacketSpam extends Check {

    @Setting(name = "whitelistedPackets")
    private static List<String> whitelistedPackets = Arrays.asList(Packet.Client.CHAT,
            Packet.Client.WINDOW_CLICK,
            "PacketPlayInSetCreativeSlot", Packet.Client.TRANSACTION, Packet.Client.KEEP_ALIVE);

    private Map<String, PacketTicks> packetsMap = new HashMap<>();

    @Setting(name = "thresholds.payloadBase")
    private static int payloadThresholdBase = 25;

    @Setting(name = "thresholds.generalBase")
    private static int generalThresholdBase = 80;

    @Setting(name = "disconnectChannel")
    private static boolean disconnectChannel = true;

    @dev.brighten.anticheat.check.api.Packet
    public void onSend(WrappedOutCustomPayload packet, long timeStamp) {
        PacketTicks packets = packetsMap.getOrDefault(Packet.Client.CUSTOM_PAYLOAD,
                new PacketTicks(0, timeStamp));

        packets.ticks--;

        packetsMap.put(Packet.Client.CUSTOM_PAYLOAD, packets);
    }

    @dev.brighten.anticheat.check.api.Packet
    public void onPosition(WrappedOutPositionPacket packet, long timeStamp) {
        PacketTicks packets = packetsMap.getOrDefault(Packet.Client.FLYING,
                new PacketTicks(0, timeStamp));

        packets.ticks--;

        packetsMap.put(Packet.Client.CUSTOM_PAYLOAD, packets);
    }

    @Event
    public boolean onReceive(PacketInfo event) {
        if(whitelistedPackets.contains(event.getType())
                || PacketProcessor.outgoingPackets.contains(event.getType())
                || event.getTimestamp() - data.creation < 1000) return false;

        PacketTicks packets = packetsMap.getOrDefault(event.getType().contains("Flying")
                        ? Packet.Client.FLYING : event.getType(),
                new PacketTicks(0, event.getTimestamp()));

        boolean cancelled = false;
        if(event.getTimestamp() - packets.lastReset <= 200) {
            int thresholdBase = event.getType().equals(Packet.Client.CUSTOM_PAYLOAD)
                    ? payloadThresholdBase : generalThresholdBase;
            if(++packets.ticks > thresholdBase) {
                vl++;
                flag(true, "ticks=" + packets.ticks + " packet=" + event.getType());
                if(packets.ticks > thresholdBase * 2) {
                    if(disconnectChannel)
                    closePlayerChannel();
                    else kickPlayer(event.getPlayer());
                }
                cancelled = true;
            } else if(packets.ticks > 5) {
                debug("type=%s ticks=%s", event.getType(), packets.ticks);
            }
        } else {
            packets.ticks = 0;
            packets.lastReset = event.getTimestamp();
        }
        packetsMap.put(event.getType(), packets);
        return cancelled;
    }

    private static void kickPlayer(Player player) {
        if(Atlas.getInstance().getBungeeManager().isBungee()) {
            BungeeAPI.kickPlayer(player.getUniqueId(), "Too many packets");
        } else RunUtils.task(() -> player.kickPlayer("Too many packets"));
    }

    @AllArgsConstructor
    @NoArgsConstructor
    public class PacketTicks {
        public int ticks;
        public long lastReset;
    }
}
